<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Henry Fox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Henry Fox&#39;s personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Henry Fox">
<meta property="og:url" content="https://fengh16.github.io/page/21/index.html">
<meta property="og:site_name" content="Henry Fox">
<meta property="og:description" content="Henry Fox&#39;s personal blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Henry Fox">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Henry Fox" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Henry Fox</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fengh16.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-linux-alias别名" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/12/linux-alias%E5%88%AB%E5%90%8D/" class="article-date">
  <time class="dt-published" datetime="2020-03-11T22:06:06.000Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8/">使用—服务器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/12/linux-alias%E5%88%AB%E5%90%8D/">linux-alias别名</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>如：<code>alias python=&quot;python3&quot;</code></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/YMaster/p/9788938.html">https://www.cnblogs.com/YMaster/p/9788938.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/12/linux-alias%E5%88%AB%E5%90%8D/" data-id="ckqkkaz1w00dqbcc45zg59x06" data-title="linux-alias别名" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java&amp;OOP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/12/Java&OOP/" class="article-date">
  <time class="dt-published" datetime="2020-03-11T22:06:06.000Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94Java/">语言—Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/12/Java&OOP/">Java&amp;OOP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java-OOP"><a href="#Java-OOP" class="headerlink" title="Java OOP"></a>Java OOP</h1><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>类型</p>
<p>接口：定义需要具有哪些属性</p>
<p>类：比较复杂的结构、存储同一个类型的多个变量</p>
<ul>
<li>封装起来不同的属性，都扔到一个桶里面</li>
<li>规定：记录下来的属性有啥&amp;能干啥</li>
<li>实例化：变成一个东西<ul>
<li>构造函数里面可以进行初始化</li>
<li>没有初始化的：基本类型设置为默认值，类的设置为null</li>
<li>从模具到东西</li>
</ul>
</li>
<li>object：对象<ul>
<li>内存一片区域</li>
<li>分成几个部分，里面分别装着属性值（instance variables，实例变量，每个object都有自己的）<ul>
<li>加上static之后就是类变量</li>
</ul>
</li>
<li>通过.来得到他的实例变量引用，可以直接进行操作<ul>
<li>解引用，de-reference</li>
</ul>
</li>
</ul>
</li>
<li>方法：<ul>
<li>构造函数（上面实例化）</li>
<li>accessor method：访问方法，只访问不修改 getter</li>
<li>update method：更新方法，进行修改setter</li>
</ul>
</li>
</ul>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><pre><code>- 重载：overloading，参数不同，方法名相同，一个类的多态性
  - ![image-20200227093906231](Java OOP&amp;数据结构.assets/image-20200227093906231.png)
- 重写：overriding，方法名参数都相同，父类子类
- ![img](Java OOP&amp;数据结构.assets/overloading-vs-overriding.png)
</code></pre>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li><p>java通过引用操作自己的对象</p>
</li>
<li><p>new函数创建一个对象，把引用给了变量（引用变量），class是引用类型</p>
<ul>
<li><p>在heap堆上开一片地方放着</p>
</li>
<li><blockquote>
<p><em>堆</em>Heap内存用于存放由new创建的对象和数组。在<em>堆</em>中分配的内存,由<em>java</em>虚拟机自动垃圾回收器来管理。</p>
</blockquote>
</li>
</ul>
</li>
<li><blockquote>
<p>Java默认new 对象则为强引用，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure>

<p>上面创建了一个StringBuffer对象，并将这个对象的强引用存到变量buffer中。如果一个对象通过一串强引用链接可到达，即使内存不足，也不会回收该对象。</p>
<p>作者：挨踢小能手<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c54d1f00ca5f">https://www.jianshu.com/p/c54d1f00ca5f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
</li>
</ul>
<h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><ul>
<li><p>不赋值默认为null，不同类型的null相等</p>
</li>
<li><p>不能转换为null，不能设置null类型</p>
</li>
<li><p>不能解引用</p>
</li>
</ul>
<blockquote>
<h3 id="1定义"><a href="#1定义" class="headerlink" title="1定义"></a>1定义</h3><p>null 是所有引用类型的默认值。</p>
<h3 id="2-转换"><a href="#2-转换" class="headerlink" title="2. 转换"></a>2. 转换</h3><p>null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，它还仅仅是一个特殊值,并不属于任何类型，用instanceof永远返回false。<br>不能将null赋给基本类型变量，例如int、double、float、boolean。如果将null赋值给包装类object，然后将object赋给各自的基本类型，编译器不会报，但是你将会在运行时期遇到空指针异常。<br>null可以被转化为任何引用类型,可以调用引用类型中的静态方法，但是不可以调用非静态方法，运行时会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class NullTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o &#x3D; (Object) null;</span><br><span class="line">        &#x2F;&#x2F;int i  &#x3D; null;</span><br><span class="line">        Integer i &#x3D; (Integer) null;</span><br><span class="line">        String s &#x3D; (String) null;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;o: &quot; + o + &quot;i: &quot; + i + &quot;s: &quot; + s);  &#x2F;&#x2F;o: nulli: nulls: null</span><br><span class="line">        System.out.println(o instanceof Object);  &#x2F;&#x2F;false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-运算"><a href="#3-运算" class="headerlink" title="3. 运算"></a>3. 运算</h3><p>null==null返回true,被转换为同种类型的null,都返回true,不同类型直接编译报错.<br>用String转换后的null可以进行字符串运算,这是因为字符串进行连接的时候,编译器对null进行了特别的优化,其实就是例化StringBuilder,在调用append()方法时对null的一个特别处理,当为null时,转化为“null”,最后调用toString()返回一个String对象.<br>用八大基本类型转换后的null,不可以进行基本类型的运算,否则会出现编译或者运行错误.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class NullTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o &#x3D; (Object) null;</span><br><span class="line">        Integer i &#x3D; (Integer) null;</span><br><span class="line">        Integer j &#x3D; (Integer) null;</span><br><span class="line">        String s &#x3D; (String) null;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(Objects.equals(i, j));</span><br><span class="line">&#x2F;&#x2F;        System.out.println(i.equals(s));</span><br><span class="line"> &#x2F;&#x2F;       System.out.println(null &#x3D;&#x3D; null);</span><br><span class="line">&#x2F;&#x2F;        i &#x3D; i + 1;   &#x2F;&#x2F;运行时空指针</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        System.out.println(2 &#x3D;&#x3D; null);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;o: &quot; + o + &quot;i: &quot; + i + &quot;s: &quot; + s);</span><br><span class="line">        System.out.println(o instanceof Object);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-集合中的key"><a href="#4-集合中的key" class="headerlink" title="4. 集合中的key"></a>4. 集合中的key</h3><table>
<thead>
<tr>
<th>集合类</th>
<th>key</th>
<th>value</th>
<th>super</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HashTable</td>
<td>不能为null</td>
<td>不能为null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不能为null</td>
<td>不能为null</td>
<td>AbstractMap</td>
<td>线程局部安全</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不能为null</td>
<td>可以为null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td>可以为null</td>
<td>可以为null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<p>hash表需要进行hash值运算，key不能为null好理解，如果map中value为null也好理解。<br>表中不好理解的是HashMap中key可以为null,看下面代码中对null有个特殊处理，索引位置为0。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6925065-619bd7c983cb75da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image.png</p>
<p>表中第二个不好理解的点是ConcurrentHashMap中value不能为null的问题。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6925065-f9cf245e2c44330c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image.png</p>
<p>作者：扎Zn了老Fe<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/83fc81baf115">https://www.jianshu.com/p/83fc81baf115</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="OOP：Object-Oriented-Programming"><a href="#OOP：Object-Oriented-Programming" class="headerlink" title="OOP：Object Oriented Programming"></a>OOP：Object Oriented Programming</h3><ul>
<li><p>基于object进行编程</p>
</li>
<li><p>数据&amp;行为</p>
</li>
</ul>
<h4 id="四大特征"><a href="#四大特征" class="headerlink" title="四大特征"></a>四大特征</h4><ul>
<li><p>抽象，封装（Encapsulation），继承（inheritance），多态（polymorphism）</p>
<ul>
<li>三大特性就是封装继承多态</li>
</ul>
</li>
</ul>
<h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><ul>
<li><p>abstraction：抽象</p>
<ul>
<li><p>不用管内部怎么实现的，内部细节对于用户隐藏的</p>
</li>
<li><p>只暴露必要的/相关的操作&amp;数据</p>
</li>
<li><p>不同层次：函数层次和类层次</p>
</li>
<li><p>![image-20200227091723756](Java OOP&amp;数据结构.assets/image-20200227091723756.png)</p>
</li>
</ul>
</li>
</ul>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul>
<li><p>不要让别人单独看到，用private</p>
<ul>
<li><p>用setxxx和getxxx</p>
</li>
<li><blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.类内部可以自由修改<br>2.可以对成员变量更准确的控制<br>3.隐藏信息，保护数据<br>4.降低<em>耦合度</em></p>
<p>耦合度：耦合性是编程中的一个判断代码模块构成质量的属性,不影响已有功能,但影响未来拓展,与之对应的是内聚性</p>
<p>例如：卧室的窗户与墙壁，如果窗子是扣死在墙里的 ，那么修改窗子时，就必须修改墙，这就比较紧密了，但是如果你窗子是按照某种规格的 可以自由拆装的 那么修改的代价就小，耦合度也就低了<br>在程序中我们要求 高内聚，低耦合！<br>————————————————<br>版权声明：本文为CSDN博主「66Kevin」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44551646/article/details/93721343">https://blog.csdn.net/weixin_44551646/article/details/93721343</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul>
<li>重载：overloading，参数不同，方法名相同，一个类的多态性</li>
<li>重写：overriding，方法名参数都相同，父类子类<ul>
<li>不想具有虚函数特性，就加上final</li>
</ul>
</li>
</ul>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul>
<li>继承：</li>
</ul>
<pre><code>- &gt;  继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
  &gt;
  &gt;  ### 生活中的继承：
  &gt;
  &gt;  ![img](Java OOP&amp;数据结构.assets/14B0951E-FC75-47A3-B611-4E1883887339.jpg)
  &gt;
  &gt;  兔子和羊属于食草动物类，狮子和豹属于食肉动物类。
  &gt;
  &gt;  食草动物和食肉动物又是属于动物类。
  &gt;
  &gt;  所以继承需要符合的关系是：is-a，父类更通用，子类更具体。
  &gt;
  &gt;  虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。
  &gt;
  &gt;  ### 类的继承格式
  &gt;
  &gt;  在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：
  &gt;
  &gt;  ## 类的继承格式
  &gt;
  &gt;  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  &gt;
  &gt;  ### 为什么需要继承
  &gt;
  &gt;  接下来我们通过实例来说明这个需求。
  &gt;
  &gt;  开发动物类，其中动物分别为企鹅以及老鼠，要求如下：
  &gt;
  &gt;  - 企鹅：属性（姓名，id），方法（吃，睡，自我介绍）
  &gt;  - 老鼠：属性（姓名，id），方法（吃，睡，自我介绍）

  -   不支持多继承，但能支持多重继承：

    - ![img](Java OOP&amp;数据结构.assets/types_of_inheritance-1.png)

  - &gt; 子类拥有父类非 private 的属性、方法。
    &gt;
    &gt; 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
    &gt;
    &gt; 子类可以用自己的方式实现父类的方法。
</code></pre>
<h6 id="Super、this"><a href="#Super、this" class="headerlink" title="Super、this"></a>Super、this</h6><blockquote>
<h3 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h3><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
</blockquote>
<h6 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h6><blockquote>
<h3 id="Final-1"><a href="#Final-1" class="headerlink" title="Final"></a>Final</h3><p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：</p>
<ul>
<li><p>声明类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;<span class="comment">//类体&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>声明方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符(<span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">default</span>/<span class="keyword">protected</span>) <span class="keyword">final</span> 返回值类型 方法名()&#123;<span class="comment">//方法体&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<ul>
<li><blockquote>
<p>子类也是父类，可以转换</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SubClass 类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">SubClass()&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line"> System.out.println(<span class="string">&quot;SubClass&quot;</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line"> System.out.println(<span class="string">&quot;SubClass(int n):&quot;</span>+n);</span><br><span class="line"> <span class="keyword">this</span>.n = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ul>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><ul>
<li><blockquote>
<p>Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。</p>
<h2 id="NameOfInterface-java-文件代码："><a href="#NameOfInterface-java-文件代码：" class="headerlink" title="NameOfInterface.java 文件代码："></a>NameOfInterface.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : NameOfInterface.java */</span></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="comment">//引入包</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameOfInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">//任何类型 final, static 字段</span></span><br><span class="line">   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口有以下特性：</p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。</li>
</ul>
</blockquote>
<ul>
<li><p>可以用<code>public class MammalInt implements Animal&#123;</code>来说明他要有这几个函数</p>
</li>
<li><blockquote>
<h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p>
<p>下面的Sports接口被Hockey和Football接口继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名: Sports.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisitingTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 文件名: Football.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfQuarter</span><span class="params">(<span class="keyword">int</span> quarter)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 文件名: Hockey.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeGoalScored</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingGoalScored</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfPeriod</span><span class="params">(<span class="keyword">int</span> period)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overtimePeriod</span><span class="params">(<span class="keyword">int</span> ot)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>在Java中，类的多继承是不合法，但接口允许多继承。</p>
<p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p>
<p>public interface Hockey extends Sports, Event</p>
<p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h6><ul>
<li>使用abstract class来定义抽象类<ul>
<li>不能被实例化，只能继承<ul>
<li><blockquote>
<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>值传递：</p>
<ul>
<li><p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<strong>但是原来的对象不会被改变（重要）。</strong></p>
</li>
<li><p>因为传递的是引用</p>
</li>
<li><p>作者：Intopass<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31203609/answer/50992895">https://www.zhihu.com/question/31203609/answer/50992895</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</li>
</ul>
</li>
<li><p>三：调用方法时发生了什么？<strong>参数传递基本上就是赋值操作</strong>。</p>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">第一个例子：基本类型</span><br><span class="line">void foo(int value) &#123;</span><br><span class="line">    value = 100;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); // num 没有被改变</span><br><span class="line"></span><br><span class="line">第二个例子：没有提供改变自身方法的引用类型</span><br><span class="line">void foo(String text) &#123;</span><br><span class="line">    text = &quot;windows&quot;;</span><br><span class="line">&#125;</span><br><span class="line">foo(str); // str 也没有被改变</span><br><span class="line"></span><br><span class="line">第三个例子：提供了改变自身方法的引用类型</span><br><span class="line">StringBuilder sb = new StringBuilder(&quot;iphone&quot;);</span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder.append(&quot;4&quot;);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。</span><br><span class="line"></span><br><span class="line">第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span><br><span class="line">StringBuilder sb = new StringBuilder(&quot;iphone&quot;);</span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder = new StringBuilder(&quot;ipad&quot;);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="final："><a href="#final：" class="headerlink" title="final："></a>final：</h3><ul>
<li><blockquote>
<p><strong>final关键字用法</strong></p>
<p><strong>修饰类<strong><strong>当用</strong></strong>final去修饰一个类的时候，表示这个类不能被继承。<strong><strong>注意：</strong></strong>a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。<strong><strong>b. final类中的成员方法都会被隐式的指定为final方法。</strong></strong>说明：</strong>在自己设计一个类的时候，要想好这个类将来是否会被继承，如果可以被继承，则该类不能使用fianl修饰，在这里呢，一般来说工具类我们往往都会设计成为一个fianl类。在JDK中，被设计为final类的有String、System等。<strong>代码：</strong></p>
<p>![img](Java OOP&amp;数据结构.assets/u=2411423419,2520809892&amp;fm=173&amp;app=25&amp;f=JPEG.jpeg)</p>
<p>\2. <strong>修饰方法</strong></p>
<p><strong>被final修饰的方法不能被重写。</strong></p>
<p><strong>注意：</strong></p>
<p><strong>a. 一个类的private方法会隐式的被指定为final方法。</strong></p>
<p><strong>b. 如果父类中有final修饰的方法，那么子类不能去重写。</strong></p>
<p><strong>代码：</strong></p>
<p>![img](Java OOP&amp;数据结构.assets/u=876634331,3528497804&amp;fm=173&amp;app=25&amp;f=JPEG.jpeg)</p>
<p><strong>3. 修饰成员变量</strong></p>
<p><strong>注意：</strong></p>
<p><strong>a. 必须要赋初始值，而且是只能初始化一次。</strong></p>
<p><strong>代码：</strong></p>
<p>![img](Java OOP&amp;数据结构.assets/u=433607551,3063868730&amp;fm=173&amp;app=25&amp;f=JPEG.jpeg)</p>
<p>\4. <strong>修饰成员变量</strong></p>
<p><strong>注意：</strong></p>
<p><strong>a. 必须初始化值。</strong></p>
<p><strong>b. 被fianl修饰的成员变量赋值，有两种方式：1、直接赋值 2、全部在构造方法中赋初值。</strong></p>
<p><strong>c. 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变。</strong></p>
<p><strong>d. 如果修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。</strong></p>
<p><strong>代码：</strong></p>
<p>![img](Java OOP&amp;数据结构.assets/u=682519727,1257936163&amp;fm=173&amp;app=25&amp;f=JPEG.jpeg)</p>
</blockquote>
</li>
</ul>
<h3 id="Static"><a href="#Static" class="headerlink" title="Static:"></a>Static:</h3><ul>
<li><p>我们可以一句话来概括：方便在没有创建对象的情况下来进行调用。</p>
</li>
<li><blockquote>
<p>2、static关键字修饰类</p>
<p>java里面static一般用来修饰成员变量或函数。但有一种特殊用法是用static修饰内部类，普通类是不允许声明为静态的，只有内部类才可以。下面看看如何使用。</p>
<p>![img](Java OOP&amp;数据结构.assets/8644ebf81a4c510f633a3493cb792028d52aa567.jpeg)</p>
<p>如果没有用static修饰InterClass，则只能new 一个外部类实例。再通过外部实例创建内部类。</p>
<p>3、static关键字修饰方法</p>
<p>修饰方法的时候，其实跟类一样，可以直接通过类名来进行调用：</p>
<p>![img](Java OOP&amp;数据结构.assets/4afbfbedab64034f7b86b4dc05e37c340b551d41.jpeg)</p>
<p>4、static关键字修饰变量</p>
<p>被static修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被static修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。</p>
<p>我们同样可以使用上面的方式进行调用变量：</p>
<p>![img](Java OOP&amp;数据结构.assets/d8f9d72a6059252d0a2aeb289fbb063e5bb5b987.jpeg)</p>
<p>5、static关键字修饰代码块</p>
<p>静态代码块在类第一次被载入时执行，在这里主要是想验证一下，类初始化的顺序。</p>
<p>父类静态变量</p>
<p>父类静态代码块</p>
<p>子类静态变量</p>
<p>子类静态代码块</p>
<p>父类普通变量</p>
<p>父类普通代码块</p>
<p>父类构造函数</p>
<p>子类普通变量</p>
<p>子类普通代码块</p>
<p>子类构造函数</p>
<p>代码验证一下：</p>
<p>首先我们定义一个父类</p>
<p>![img](Java OOP&amp;数据结构.assets/faf2b2119313b07ed299fae9a6f7942696dd8cd4.jpeg)</p>
<p>然后定义一个子类</p>
<p>![img](Java OOP&amp;数据结构.assets/37d3d539b6003af36f87b1b99f0ac3591138b6cb.jpeg)</p>
<p>看个结果</p>
<p>![img](Java OOP&amp;数据结构.assets/d009b3de9c82d158c5bd9c3e2a2a1cddbc3e4223.jpeg)</p>
<p>二、深入分析static关键字</p>
<p>上面我们只是描述了一下static关键字的基本使用场景，下面主要解析一下static关键字的深层原理。要理解static为什么会有上面的特性，首先我们还需要从jvm内存说起。我们先给出一张java的内存结构图，然后通过案例描述一下static修饰的变量存放在哪？</p>
<p>![img](Java OOP&amp;数据结构.assets/024f78f0f736afc33409f1471839eec1b74512b4.jpeg)</p>
<p>从上图我们可以发现，静态变量存放在方法区中，并且是被所有线程所共享的。这里要说一下java堆，java堆存放的就是我们创建的一个个实例变量。</p>
<p>堆区:</p>
<p>1、存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)</p>
<p>2、jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身</p>
<p>栈区:</p>
<p>1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中</p>
<p>2、每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。</p>
<p>3、栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。、</p>
<p>方法区:</p>
<p>1、又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。</p>
<p>2、方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p>
<p>下面通过一个案例说明一下，从内存的角度来看，static关键字为什么会有这样的特性。</p>
<p>首先我们定义一个类</p>
<p>![img](Java OOP&amp;数据结构.assets/359b033b5bb5c9ea023ba6fe7e19b3053bf3b38c.jpeg)</p>
<p>接下来我们从内存的角度出发，看看</p>
<p>![img](Java OOP&amp;数据结构.assets/f3d3572c11dfa9ec028d9199c8f0f206908fc147.jpeg)</p>
<p>从上面可以看到，我们的方法在调用的时候，是从方法区调用的，但是堆内存不一样，堆内存中的成员变量lastname是随着对象的产生而产生。随着对象的消失而消失。静态变量是所有线程共享的，所以不会消失。这也就能解释上面static关键字的真正原因。</p>
<p>下面对static关键字进行一个小结：</p>
<p>（1）特点：</p>
<p>1、static是一个修饰符，用于修饰成员。（成员变量，成员函数）static修饰的成员变量 称之为静态变量或类变量。</p>
<p>2、static修饰的成员被所有的对象共享。</p>
<p>3、static优先于对象存在，因为static的成员随着类的加载就已经存在。</p>
<p>4、static修饰的成员多了一种调用方式，可以直接被类名所调用，（类名.静态成员）。</p>
<p>5、static修饰的数据是共享数据，对象中的存储的是特有的数据。</p>
<p>（2）成员变量和静态变量的区别：</p>
<p>1、生命周期的不同：</p>
<p>成员变量随着对象的创建而存在随着对象的回收而释放。</p>
<p>静态变量随着类的加载而存在随着类的消失而消失。</p>
<p>2、调用方式不同：</p>
<p>成员变量只能被对象调用。</p>
<p>静态变量可以被对象调用，也可以用类名调用。（推荐用类名调用）</p>
<p>3、别名不同：</p>
<p>成员变量也称为实例变量。</p>
<p>静态变量称为类变量。</p>
<p>4、数据存储位置不同：</p>
<p>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。</p>
<p>静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</p>
<p>（3）静态使用时需要注意的事项：</p>
<p>1、静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）</p>
<p>2、静态方法中不可以使用this或者super关键字。</p>
<p>3、主函数是静态的</p>
<p>好了，static关键字就介绍道这里，谢谢您的支持，如有问题，还请批评指正</p>
</blockquote>
</li>
<li><blockquote>
<p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    Test5.a=<span class="number">3</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    Test5 t=<span class="keyword">new</span> Test5();</span><br><span class="line">    t.f();</span><br><span class="line">    t.b=<span class="number">1000</span>;</span><br><span class="line">    System.out.println(t.b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    Test5.a=<span class="number">4</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO 自动生成方法存根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    Test5.a=<span class="number">5</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;hhahhahah&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>　　运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">hhahhahah</span><br><span class="line">1000</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>　　利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。　</p>
<p>　　<strong>4、static和final一块用表示什么</strong><br>　　static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br>　　对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br>　　对于方法，表示不可覆盖，并且可以通过类名直接访问。</p>
</blockquote>
</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this:"></a>this:</h3><ul>
<li>指代自己变量的，防止被覆盖</li>
<li>可以调用对应的构造函数</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/12/Java&OOP/" data-id="ckqkkaz5d00pgbcc4d5uehah3" data-title="Java&amp;OOP" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-scipy说明" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/11/scipy%E8%AF%B4%E6%98%8E/" class="article-date">
  <time class="dt-published" datetime="2020-03-10T22:06:06.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94Python/">语言—Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/11/scipy%E8%AF%B4%E6%98%8E/">scipy说明</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c742912047f">https://www.jianshu.com/p/6c742912047f</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/11/scipy%E8%AF%B4%E6%98%8E/" data-id="ckqkkaz2g00fibcc437wk2mz4" data-title="scipy说明" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-每日leetcode-145" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/11/%E6%AF%8F%E6%97%A5leetcode-145/" class="article-date">
  <time class="dt-published" datetime="2020-03-10T22:06:06.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/11/%E6%AF%8F%E6%97%A5leetcode-145/">每日leetcode-145</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>二叉树的后序遍历。</p>
<h2 id="两个栈方式的"><a href="#两个栈方式的" class="headerlink" title="两个栈方式的"></a>两个栈方式的</h2><p>直接看<a target="_blank" rel="noopener" href="http://www.bilibili.com/video/av23885544/">http://www.bilibili.com/video/av23885544/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; nodes;</span><br><span class="line">        stack&lt;<span class="keyword">bool</span>&gt; tag;</span><br><span class="line">        nodes.<span class="built_in">push</span>(root);</span><br><span class="line">        tag.<span class="built_in">push</span>(<span class="literal">false</span>); <span class="comment">// 标记应不应该访问nodes的第一个元素</span></span><br><span class="line">        TreeNode* p = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (p || !nodes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                nodes.<span class="built_in">push</span>(p);</span><br><span class="line">                tag.<span class="built_in">push</span>(<span class="literal">false</span>);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tag.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 这个时候已经访问了nodes这个stack里面第一个节点的左右子树了，所以需要访问nodes这个节点，之后就pop出来，继续访问他的上面没有访问的节点或者右子树</span></span><br><span class="line">                    tag.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">auto</span> a = nodes.<span class="built_in">top</span>();</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(a-&gt;val);</span><br><span class="line">                    nodes.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tag.<span class="built_in">pop</span>();</span><br><span class="line">                    tag.<span class="built_in">push</span>(<span class="literal">true</span>);</span><br><span class="line">                    p = nodes.<span class="built_in">top</span>()-&gt;right;  <span class="comment">// 这时候要访问右子树了！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前序遍历改一下"><a href="#前序遍历改一下" class="headerlink" title="前序遍历改一下"></a>前序遍历改一下</h2><p>前序遍历的时候，把左右子树进栈的顺序反一下，得到的结果就是后序遍历的反向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; nodes;</span><br><span class="line">        nodes.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!nodes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = nodes.<span class="built_in">top</span>();</span><br><span class="line">            nodes.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (a) &#123;</span><br><span class="line">                ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(), a-&gt;val);</span><br><span class="line">                nodes.<span class="built_in">push</span>(a-&gt;left);</span><br><span class="line">                nodes.<span class="built_in">push</span>(a-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/11/%E6%AF%8F%E6%97%A5leetcode-145/" data-id="ckqkkaz4500l3bcc4bv3e9r01" data-title="每日leetcode-145" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-词云生成" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/11/%E8%AF%8D%E4%BA%91%E7%94%9F%E6%88%90/" class="article-date">
  <time class="dt-published" datetime="2020-03-10T22:06:06.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94Python/">语言—Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/11/%E8%AF%8D%E4%BA%91%E7%94%9F%E6%88%90/">词云生成</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91382540">https://zhuanlan.zhihu.com/p/91382540</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/11/%E8%AF%8D%E4%BA%91%E7%94%9F%E6%88%90/" data-id="ckqkkaz5000o5bcc4305panc1" data-title="词云生成" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-每日leetcode-140" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/09/%E6%AF%8F%E6%97%A5leetcode-140/" class="article-date">
  <time class="dt-published" datetime="2020-03-08T22:06:06.000Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/09/%E6%AF%8F%E6%97%A5leetcode-140/">每日leetcode-140</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol start="140">
<li>单词拆分 II</li>
</ol>
<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p><strong>说明：</strong></p>
<ul>
<li>  分隔时可以重复使用字典中的单词。</li>
<li>  你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong>输入:</strong> s = “<code>catsanddog</code>“<br>wordDict = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code><br><strong>输出:</strong> <code>[   &quot;cats and dog&quot;,   &quot;cat sand dog&quot; ]</code></p>
<p><strong>示例 2：</strong></p>
<p><strong>输入:</strong> s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br><strong>输出:</strong> [<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br><strong>解释:</strong> 注意你可以重复使用字典中的单词。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入:</strong> s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>输出:</strong> []</p>
<h2 id="简单递归写法"><a href="#简单递归写法" class="headerlink" title="简单递归写法"></a>简单递归写法</h2><p>会超时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = wordDict.<span class="built_in">begin</span>(); i != wordDict.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">rfind</span>(*i, <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">size</span>() == (*i).<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(*i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">auto</span> m = <span class="built_in">wordBreak</span>(s.<span class="built_in">substr</span>((*i).<span class="built_in">size</span>()), wordDict);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> t = m.<span class="built_in">begin</span>(); t != m.<span class="built_in">end</span>(); t++) &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(*i + <span class="string">&quot; &quot;</span> + *t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加上记录，不多算"><a href="#加上记录，不多算" class="headerlink" title="加上记录，不多算"></a>加上记录，不多算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; memo;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreakIndex</span><span class="params">(string&amp; s, vector&lt;string&gt;&amp; wordDict, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(index) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[index];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = wordDict.<span class="built_in">begin</span>(); i != wordDict.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">rfind</span>(*i, index) == index) &#123;</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">size</span>() == index + (*i).<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(*i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">auto</span> m = <span class="built_in">wordBreakIndex</span>(s, wordDict, index + (*i).<span class="built_in">size</span>());</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> t = m.<span class="built_in">begin</span>(); t != m.<span class="built_in">end</span>(); t++) &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(*i + <span class="string">&quot; &quot;</span> + *t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[index] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        memo.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">wordBreakIndex</span>(s, wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 : 112 ms, 在所有 C++ 提交中击败了5.27%的用户</span><br><span class="line">内存消耗 : 11.2 MB, 在所有 C++ 提交中击败了77.66%的用户</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/09/%E6%AF%8F%E6%97%A5leetcode-140/" data-id="ckqkkaz4200kzbcc4e51m1ige" data-title="每日leetcode-140" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-iPhone打开html网页和代码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/07/iPhone%E6%89%93%E5%BC%80html%E7%BD%91%E9%A1%B5%E5%92%8C%E4%BB%A3%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2020-03-06T22:06:06.000Z" itemprop="datePublished">2020-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E6%97%A5%E5%B8%B8%E7%B3%BB%E7%BB%9F/">使用—日常系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/07/iPhone%E6%89%93%E5%BC%80html%E7%BD%91%E9%A1%B5%E5%92%8C%E4%BB%A3%E7%A0%81/">iPhone打开html网页和代码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>可以把它保存到icloud，之后用“文件”这个软件打开。打开的时候长按选择“快速查看”</p>
<p>如果要看源代码，Code Viewer是可以的。CodeViewer可以用来打开代码看一下，修改的话用textastic</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/07/iPhone%E6%89%93%E5%BC%80html%E7%BD%91%E9%A1%B5%E5%92%8C%E4%BB%A3%E7%A0%81/" data-id="ckqkkaz1o00csbcc41nl7bojf" data-title="iPhone打开html网页和代码" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-每日leetcode-337" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/07/%E6%AF%8F%E6%97%A5leetcode-337/" class="article-date">
  <time class="dt-published" datetime="2020-03-06T22:06:06.000Z" itemprop="datePublished">2020-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/07/%E6%AF%8F%E6%97%A5leetcode-337/">每日leetcode-337</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol start="337">
<li>打家劫舍 III</li>
</ol>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> [3,2,3,null,3,null,1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line"> \   \ </span><br><span class="line">  3   1</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 7<br><strong>解释:</strong> 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = <strong>7</strong>.</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> [3,4,5,1,3,null,1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \   \ </span><br><span class="line">1   3   1</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 9<br><strong>解释:</strong> 小偷一晚能够盗取的最高金额 = <strong>4</strong> + <strong>5</strong> = <strong>9</strong>.</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用后序遍历非递归，分别记录每一个节点的抢劫能抢到的钱，以及不抢它能抢到的钱，总之还是动态规划。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;TreeNode*, <span class="keyword">int</span>&gt; data;  <span class="comment">// 抢了这个节点的话，可以有多少钱</span></span><br><span class="line">        unordered_map&lt;TreeNode*, <span class="keyword">int</span>&gt; pre;  <span class="comment">// 不抢这个节点的话，可以有多少钱</span></span><br><span class="line">        <span class="comment">// 后序遍历，先把孩子整完了，在整爹，具体看http://www.bilibili.com/video/av23885544/</span></span><br><span class="line">        <span class="comment">// 每一次后序遍历的时候，先把指针p指向左子树，再对根节点做个标记后指向右子树</span></span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        stack&lt;TreeNode*&gt; tree;</span><br><span class="line">        stack&lt;<span class="keyword">bool</span>&gt; check;</span><br><span class="line">        <span class="keyword">while</span> (p || !tree.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                tree.<span class="built_in">push</span>(p);</span><br><span class="line">                check.<span class="built_in">push</span>(<span class="literal">false</span>);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">bool</span> need_pop = check.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (need_pop) &#123;</span><br><span class="line">                    TreeNode* check_node = tree.<span class="built_in">top</span>();</span><br><span class="line">                    check.<span class="built_in">pop</span>();</span><br><span class="line">                    tree.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">int</span> check_val = check_node-&gt;val;;</span><br><span class="line">                    <span class="keyword">int</span> pre_val = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (check_node-&gt;left) &#123;</span><br><span class="line">                        check_val += pre[check_node-&gt;left];</span><br><span class="line">                        pre_val += data[check_node-&gt;left];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (check_node-&gt;right) &#123;</span><br><span class="line">                        check_val += pre[check_node-&gt;right];</span><br><span class="line">                        pre_val += data[check_node-&gt;right];</span><br><span class="line">                    &#125;</span><br><span class="line">                    data[check_node] = <span class="built_in">max</span>(check_val, pre_val);</span><br><span class="line">                    pre[check_node] = pre_val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    check.<span class="built_in">pop</span>();</span><br><span class="line">                    check.<span class="built_in">push</span>(<span class="literal">true</span>);</span><br><span class="line">                    p = tree.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[root];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://www.bilibili.com/video/av23885544/">http://www.bilibili.com/video/av23885544/</a> 这里的后序遍历非递归的说明挺清楚的</p>
<h2 id="后序遍历递归版本"><a href="#后序遍历递归版本" class="headerlink" title="后序遍历递归版本"></a>后序遍历递归版本</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;TreeNode*, <span class="keyword">int</span>&gt; data;  <span class="comment">// 抢了这个节点的话，可以有多少钱</span></span><br><span class="line">        unordered_map&lt;TreeNode*, <span class="keyword">int</span>&gt; pre;  <span class="comment">// 不抢这个节点的话，可以有多少钱</span></span><br><span class="line">        <span class="comment">// 这次直接用递归方式的后序遍历</span></span><br><span class="line">        <span class="built_in">search</span>(root, data, pre);</span><br><span class="line">        <span class="keyword">return</span> data[root];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode* check_node, unordered_map&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; data, unordered_map&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> check_val = check_node-&gt;val;;</span><br><span class="line">        <span class="keyword">int</span> pre_val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (check_node-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">search</span>(check_node-&gt;left, data, pre);</span><br><span class="line">            check_val += pre[check_node-&gt;left];</span><br><span class="line">            pre_val += data[check_node-&gt;left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check_node-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">search</span>(check_node-&gt;right, data, pre);</span><br><span class="line">            check_val += pre[check_node-&gt;right];</span><br><span class="line">            pre_val += data[check_node-&gt;right];</span><br><span class="line">        &#125;</span><br><span class="line">        data[check_node] = <span class="built_in">max</span>(check_val, pre_val);</span><br><span class="line">        pre[check_node] = pre_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实比上面的要慢，主要是因为unordered_map的使用，其实并不需要用这个map，每一次返回两个数就行</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>换成返回两个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这次直接用递归方式的后序遍历</span></span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">search</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;int, int&gt; search(TreeNode* check_node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!check_node) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">search</span>(check_node-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">search</span>(check_node-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> check_val = check_node-&gt;val + left.second + right.second;</span><br><span class="line">        <span class="keyword">int</span> pre_val = left.first + right.first;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">max</span>(check_val, pre_val), pre_val&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/07/%E6%AF%8F%E6%97%A5leetcode-337/" data-id="ckqkkaz4a00lnbcc44pqi4mng" data-title="每日leetcode-337" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Notability" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/05/Notability/" class="article-date">
  <time class="dt-published" datetime="2020-03-04T22:06:06.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94%E5%85%B6%E4%BB%96/">使用—软件—其他</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/05/Notability/">Notability</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>打开就开始从网上下载一直转圈：iPad存储内存不够了（</p>
<p>mac上面找到自己的文件：直接搜索笔记名，加上.nbn后缀，搜到后打开上层文件夹，这个是在icloud里面的</p>
<p>元数据错误：直接找历史版本，如果找不到的话<strong>多试几次</strong>就有了……不懂原理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/05/Notability/" data-id="ckqkkayzs006jbcc45142eqqn" data-title="Notability" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-iCloud相关用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/05/iCloud%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-03-04T22:06:06.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94%E5%85%B6%E4%BB%96/">使用—软件—其他</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/05/iCloud%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/">iCloud相关用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://sspai.com/post/44602">https://sspai.com/post/44602</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengh16.github.io/2020/03/05/iCloud%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/" data-id="ckqkkaz1n00cobcc48x51gpaz" data-title="iCloud相关用法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/20/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/40/">40</a><a class="extend next" rel="next" href="/page/22/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E6%97%A5%E5%B8%B8%E7%B3%BB%E7%BB%9F/">使用—日常系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8/">使用—服务器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E5%A4%9A%E8%BF%9B%E7%A8%8B/">使用—编程模式—多进程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94Antlr4/">使用—软件—Antlr4</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94Django/">使用—软件—Django</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94Git/">使用—软件—Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94RN/">使用—软件—RN</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94Selenium/">使用—软件—Selenium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94TF/">使用—软件—TF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94docker/">使用—软件—docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%BF%E7%94%A8%E2%80%94%E8%BD%AF%E4%BB%B6%E2%80%94%E5%85%B6%E4%BB%96/">使用—软件—其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E9%9B%86/">数据集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8/">系统使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94C/">语言—C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94Haskell/">语言—Haskell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94Java/">语言—Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94PHP/">语言—PHP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94Python/">语言—Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94R%E8%AF%AD%E8%A8%80/">语言—R语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80%E2%80%94%E6%B1%87%E7%BC%96/">语言—汇编</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B5%84%E6%BA%90/">资源</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/">软件使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%91%E8%9E%8D/">金融</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94FTP%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">领域—FTP计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94Win32%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/">领域—Win32桌面程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">领域—人工智能神经网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E5%89%8D%E7%AB%AF/">领域—前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/">领域—微信公众号</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E6%93%8D%E7%BB%9F%E2%80%94xv6/">领域—操统—xv6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E6%95%B0%E5%AD%A6/">领域—数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E6%B5%8B%E8%AF%95/">领域—测试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">领域—社交网络推荐系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">领域—软件工程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%86%E5%9F%9F%E2%80%94%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF/">领域—黑客技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CLion/" rel="tag">CLion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GNN/" rel="tag">GNN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kaggle/" rel="tag">Kaggle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyCharm/" rel="tag">PyCharm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tensorflow/" rel="tag">tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/" rel="tag">数据集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/" rel="tag">服务器开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/" rel="tag">社交网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A4%BE%E5%8C%BA%E5%88%92%E5%88%86/" rel="tag">社区划分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" rel="tag">神经网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8/" rel="tag">系统使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/" rel="tag">软件使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9C%E7%A8%8B/" rel="tag">远程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CLion/" style="font-size: 10px;">CLion</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 12.5px;">C语言</a> <a href="/tags/GNN/" style="font-size: 12.5px;">GNN</a> <a href="/tags/Kaggle/" style="font-size: 10px;">Kaggle</a> <a href="/tags/PyCharm/" style="font-size: 10px;">PyCharm</a> <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/tensorflow/" style="font-size: 10px;">tensorflow</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/" style="font-size: 12.5px;">数据集</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 15px;">服务器</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/" style="font-size: 15px;">服务器开发</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/" style="font-size: 12.5px;">社交网络</a> <a href="/tags/%E7%A4%BE%E5%8C%BA%E5%88%92%E5%88%86/" style="font-size: 12.5px;">社区划分</a> <a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 20px;">神经网络</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">系统使用</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 17.5px;">转载</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/" style="font-size: 20px;">软件使用</a> <a href="/tags/%E8%BF%9C%E7%A8%8B/" style="font-size: 15px;">远程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/01/Machine%20Learning%20in%20Action/">Machine Learning in Action总结</a>
          </li>
        
          <li>
            <a href="/2021/06/29/Windows-%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/">Windows-修改远程桌面</a>
          </li>
        
          <li>
            <a href="/2021/06/28/switch%E6%A8%A1%E6%8B%9F%E5%99%A8/">switch模拟器</a>
          </li>
        
          <li>
            <a href="/2021/06/27/latex-label%E4%B8%8D%E5%AF%B9/">latex-label不对</a>
          </li>
        
          <li>
            <a href="/2021/06/27/latex-%E6%8E%92%E7%89%88/">latex-排版</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Henry Fox<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>